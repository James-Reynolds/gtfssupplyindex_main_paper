---
title: "Leveraging GTFS to explore spatial patterns in transit supply with respect to social needs"
author:
  - name: James Reynolds
    email: james.reynolds@monash.edu
    affiliation: Public Transport Research Group (PTRG)
    correspondingauthor: false
    footnote: 1
  - name: Graham Currie
    email: graham.currie@monash.edu
    affiliation: Public Transport Research Group (PTRG)
    correspondingauthor: true
    footnote: 2
  - name: Yanda Qu
    email: yanda.qu@monash.edu
    affiliation: Public Transport Research Group (PTRG)
    footnote: 3
  
address:
  - code: Public Transport Research Group (PTRG)
    organization: Public Transport Research Group (PTRG), Institute of Transport Studies, Department of Civil Engineering Engineering, Monash University
    addressline: Clayton Campus
    city: Melbourne 
    state: Victoria
    postcode: 3800
    country: Australia
  
footnote:
  - code: 1
    text: "Research Fellow"
  - code: 2
    text: "Professor"
  - code: 3
    text: "PhD Student"

abstract: |
  This is the abstract.

  It consists of two paragraphs.
keywords: 
  - keyword1
  - keyword2
journal: "Transport Geography?"
date: "`r Sys.Date()`"
classoption: preprint, 3p, authoryear
bibliography: References.bib, packages.bib
linenumbers: false
numbersections: true
# Use a CSL with `citation_package = "default"`
# csl: https://www.zotero.org/styles/elsevier-harvard
output: 
  rticles::elsevier_article:
    keep_tex: true
    citation_package: natbib
    extra_dependencies: "subfig"
    fig_caption: true
---



```{r setup, include=FALSE}
library(tidyverse)
library(tidytransit)
library(sp)
library(strayr)
library(ptinpoly)
library(magrittr)
library(ggplot2)
library(sf)
library(ASGS.foyer)
library(raster)
library(ggmap)
library(units)
library(janitor)
library(mapview)
library(ggstatsplot)
library(gtsummary)
library(moments)
library(scales)
library(gtfstools)
library(lubridate)
library(kableExtra)
library(knitr)
library(readxl)
library(readr)
library(dplyr)
library(devtools)
library(gtfssupplyindex)
library(readabs)
library(gglorenz)
library(DescTools)
library(RColorBrewer)
library(lsr)
library(ggpubr)
library(viridis)
library(geosphere)


# invalidate cache when the tufte version changes
#knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))

```



# Introduction
Providing basic mobility 
for those who cannot otherwise drive 
is a key purpose for transit 
in many places [@Currie:2016aa].
Age, 
disability, 
socio-economic status, 
lack of a driver's license 
or vehicle, 
and many other factors 
might make someone
reliant on 
transit services 
for some or all of their travel. 
Approaches for identifying 
spatial gaps in transit supply,     
where is a high or very high social need 
yet little or no service, have 
been reported in previous research [@Currie2003Hobart; 
@Currie2004Gap;
@Currie2007Identifying; @currie2010identifying].

However, in the almost two decades since
there does not appear to have been much further use or development 
of these approach. 
As well, it is unclear if
the spatial patterns 
identified in this previous research 
are representative of 
transit supply and social need 
in other places,
or whether the location of gaps have changed in the intervening years.
This may in part be because 
at the time transit schedule data 
was not readily available in 
a consistent, electronic formats. 

Nowadays, however, 
more than 10,000 transit agencies 
publicly release schedule data 
in the General Transit Feed Specification (GTFS)
format. 
Various tools for manipulating such datasets 
are also now available, 
including software for 
validating, 
analysing 
and visualizating GTFS, 
as well as a separate standard 
(GTFS-Realtime) for sharing 
live vehicle locations [@GTFS].

However, software tools
for examining spatial 
patterns and gaps 
in transit supply 
with respect to 
social needs for transport
appears limited.
This gap and the lack of 
direct follow up 
to @Currie2003Hobart, 
@Currie2004Gap, 
@Currie2007Identifying 
and @currie2010identifying 
provide the motivation 
for this paper.
The three main objectives of the research are: 
(1) to develop tools for undertaking needs-gap analysis 
using GTFS datasets; 
(2) to explore whether such gaps have changed in the intervening years; 
and (3) to better understand whether spatial patterns in 
Melbourne are representative of those in other places.

This research included 
the development of a new R package (gtfssupplyindex) 
with software tools 
that facilitate the 
use of the 
@Currie2003Hobart, 
@Currie2004Gap, 
@Currie2007Identifying 
and @currie2010identifying
approach, 
in particular the calculation of
transit Supply Index (SI) scores 
from GTFS datasets. 
Also presented in this paper 
are results for Australian cities in 2016 and 2021, 
matching the most recent censuses, 
which are compared across locations 
and to the 2006 analysis
of Melbourne reported in @currie2010identifying.

The remainder of this paper is structured as follows:
the next section outlines the background to this research. 
Section 3 describes the study methodology, 
followed by presentation of results in Section 4 
and discussion in Section 5. 
Limitations of this study, 
directions for future research and 
a brief conclusion are provided in Section 6. 

# Background
## Transit metrics
There are 
many metrics 
available for benchmarking transit services, 
including those in 
the Transit Cooperative Research Program (TCRP) Report 88 guidebook 
on developing performance-measurement systems [@Ryus:2003aa]; 
and those
used across benchmarking databases and programs 
(e.g. @Florida-Transit-Information-System:2018aa, @UITP:2015aa @Imperial-College-London:2023aa;
The Fielding Triangle [@FieldingGordonJ1987Mpts] 
provides a framework 
for combining indicators of 
service inputs, 
outputs 
and consumption 
to describe cost efficiency, 
cost effectiveness and
service effectiveness. 
More broadly: @Litman:2003ab 
and @Litman:2016aa 
discuss some of the traffic, 
mobility, 
accessibility, 
social equity, 
strategic planning 
and other rational decision-making-based
perspectives underling transport indicators; 
@Reynolds:2017ah extends 
these into models of how 
institutionalism, 
incrementalism 
and other public policy analysis concepts 
might apply to decision-making processes 
relating to transit prioritization; 
@GuzmanLuisA.2017Aeit developed a measure of accessibility 
in the context of policy development 
and social equity 
for Latin American Bus Rapid Transit (BRT) networks; and 
@Creutzig2020streetspaceallocation
introduced street space allocation metrics 
based around ten ethical principles. 

However, 
many of these metrics 
may be difficult to calculate, 
explain or understand, 
especially for those who are not planners, engineers 
or other technical specialists. 
Where pre-calculated transit metrics 
are immediately available, 
such as on a website or 
other online platform, 
it may not be possible
to independently generate scores, 
for instance to assess proposed system changes. 
Contrasting examples are provided by the metrics in the 
Transit Capacity and Quality of Service Manual (TCQSM) 
and the Transit Score website [@WalkScore:2023tg]:

- Transit Scores are readily available online 
for locations with a published GTFS feed. 
The meaning of the metric
also appears easy to explain, 
with the highest possible score of 100 
representing the sort of transit accessibility 
experienced in the center of New York. 
However, 
the Transit Score algorithm 
is secret, 
and scores cannot be calculated independently
or generated 
for proposed changes to networks. 

- The TCQSM provides a wide range of metrics 
for measuring different aspects of a transit system. 
The TCQSM scores themselves appear easy to understand or explain, 
ranging from A (good) to F (bad), 
although the large number of metrics 
might be somewhat overwhelming for some users.
The scores, however, 
can be calculated independently, given sufficient data. 

The widespread availability of GTFS datasets 
in recent years has facilitated the development of tools, 
such as the Transit Score, 
that apply the same metric to many transit systems. 
@Wong:2013aa provides another example of what can be done 
with GTFS data, 
open metrics and coding,
by reporting the distribution of
various TCQSM metrics 
across 50 USA transit operators. 
Code used in the 
@Wong:2013aa analysis 
is available 
for those who might wish 
to produce a similar study 
for other locations and systems. 


## The Transit Suppy Index
An objective of this study is to 
produce code that 
facilitates calculation of the SI metric
from GTFS data. 
A generalized form of the SI equation, 
adapted from @currie2010identifying, 
is: 

  $$SI_{area, time} = \sum{\frac{Area_{Bn}}{Area_{area}}*SL_{n, time}}$$

where:

- $SI_{area, time}$ is the Supply Index for the area of interest 
and a given period of time;

- $Area_{Bn}$ is the buffer area for each stop (n) within the area of interest 
(in @currie2010identifying this was based on 
a radius of 400 metres for bus and tram stops, 
and 800 metres for railway stations);

- $Area_{area}$ is the area of the area of interest; and

- $SL_{n,time}$ is the number of transit arrivals for each stop 
for a given time period.

```{r Currie_map_SI, fig.cap = "Distribution of supply measure scores – Metropolitan Melbourne (2006), Source: Currie (2010)",  echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, out.width='100%'}

knitr::include_graphics("graphics/Currie2010SI.png")

```

@currie2010identifying reported SI scores 
for Census Collection Districts (CCDs) 
across Greater Melbourne in 2006, 
as shown in 
Figure \ref{fig:Currie_map_SI}.  
They identified general patterns of
more transit supply 
in the middle and inner suburbs
and along passenger railway lines; and 
outer areas tending to have very low SI scores 
or no transit supply at all. 

## Social need and needs gap


```{r Currie_chart_gap, fig.cap = "Log supply score and need index values – Melbourne needs-gap study, Source: Currie (2010)",  echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, out.width='100%'}

#knitr::include_graphics("graphics/Currie2010chart.png")

```


```{r Currie_map_needs, fig.cap = "Distribution of categories of composite social need index scores in 2006, Source: Currie (2010)",  echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, out.width='100%'}

knitr::include_graphics("graphics/Currie2010Needs.png")

```

As well as measuring transit supply, @currie2010identifying also 
assessed the social need for transit 
across Greater Melbourne using: 
the Australian Bureaus of Statistics' Index of Related Socio-Economic Advantage/Disadvantage (IRSAD) and 
a transport needs index derived 
from eight weighted indicators.
The spatial distribution of this 
composite social needs index in 2006, 
reproduced in Figure \ref{fig:Currie_map_needs), 
indicates areas of 
above average, 
high and
very high 
social needs 
in 2006 were located in: 
some outer areas, 
particularly in the east and south-east; 
and in some middle areas in the south-east,
north and west. 


```{r Currie_map_gap, fig.cap = "Melbourne needs-gap in 2006 – very high transport need areas with zero or very low public transport supply, Source: Currie (2010)",  echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, out.width='100%'}

knitr::include_graphics("graphics/Currie2010gap.png")

```
 

As the final step in the spatial needs-gap analysis, 
@currie2010identifying identified 
areas with very high transport needs, 
but very low or no transit supply,  
as reproduced in Figure \ref{fig:Currie_map_gap}. 
This indicated areas 
where service gaps might be of particular concern, 
Most of these were located in outer parts of Melbourne 
in the north-east, south-east and south, 
although there were also some pockets 
in the middle suburbs in the west, north and south east.
Overall, @currie2010identifying found that 
"8.2% of Melbourne residents have ‘very high’ needs 
but ‘zero’, ‘low’ or ‘very low’ public transport supply."
Using this methodology in transit planning 
was also suggested as
"substantially more useful than the presentation of anecdotal evidence, 
which is the most common means 
of identifying transport needs 
in local transport studies throughout the world."[@currie2010identifying]

However, it does not appear that this approach 
has been widely adopted 
in practice 
or further developed by researchers. 
Our suspicion is that while the SI has a relatively simple formula 
and requires only geographic and timetable data, 
the lack of software tools 
may be partly why it has not been more widely adopted.

It is also unclear 
whether the patterns in Melbourne 
identified in @currie2010identifying 
have changed 
since the 2006 analysis, 
or if Melbourne is representative of other locations. 
Developing a software tool 
to calculate SI tools from GTFS data, 
and then using it to comparing current conditions and other locations 
to the findings of @currie2010identifying, 
therefore, provides the motivation 
for this research.


# Methodology
## Code development

This study developed
a package of tools 
for calculating the SI from GTFS data 
using the R programming language [@R-base].
The recommendations of @wickham2023r 
informed the package setup and 
development approach. 
Various existing packages 
and code examples
were relied upon including: 
the sf package [@R-sf] for geospatial analysis; 
the tidyverse [@tidyverse2019]; 
gtfstools [@R-gtfstools]; and 
tidytransit [@R-tidytransit]. 
Australian Bureau of Statistics (ABS) data was also used, sourced via the strayr 
and absmapsdata packages [@r-strayr].

Code was developed and tested on 
the Mornington Peninsula Tourist Railway GTFS feed. 
This was selected primarily for convenience, 
given that the authors are familiar with 
the surrounding geography 
and that the feed covers 
a small number of trips across 
just three stations.  

## Changes since 2006: Greater Melbourne
Much has changed since 2006, 
including the spatial geography used by the 
Australian Bureau of Statistics (ABS) to collect census data. 
To allow direct comparison between 2006 and now, therefore, 
this study calculated SI scores 
using the same 
Census Collection Districts (CCDs) used by 
@currie2010identifying, 
but for the week starting the day of the 2021 census
The Victorian GTFS feed, 
published by Public Transport Victoria (PTV), 
was used, with historical feeds sourced via @transitfeeds_victoria:2023aa. 


```{r fix_ptv_data_Victoria_210805, eval = FALSE, echo = FALSE}

ptv_210805 <- tidytransit::read_gtfs("data/ptv_210805/gtfs.zip")
# This results in "Warning: Duplicated ids found in: stops The returned object is not a tidygtfs object, you can use as_tidygtfs() after fixing the issue."

#So, remove the duplicated stops 
#identify duplicate stops
ptv_210805_duplicated_stops <- tabyl(ptv_210805$stops$stop_id) %>% filter (n>1)
names(ptv_210805_duplicated_stops) <- c("stop_id", "n", "percent")
ptv_210805_duplicated_stops <- left_join(ptv_210805_duplicated_stops, ptv_210805$stops)

##discard duplicates
ptv_210805$stops <- ptv_210805$stops[!duplicated(ptv_210805$stops$stop_id),]

## Write gtfs back to file
ptv_210805 <- as_tidygtfs(ptv_210805)
tidytransit::write_gtfs(ptv_210805, "data/ptv_210805/gtfs_duplicate_stops_removed.zip")

## convert to list of tidygtfs objects
ptv_210805_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/ptv_210805/gtfs_duplicate_stops_removed.zip")

```

```{r run_for_all_modes_Victoria_210810_CCD, eval = FALSE, echo = FALSE}
list_gtfs = ptv_210805_list_gtfs

#ccd_vic_2006 <- st_read("data/1259030002_cd06avic_shape/CD06aVIC.shp")

asgc2006 <- st_read("data/asgc2006.gpkg", layer = "census_collection_district_2006")
st_geometry(asgc2006) <- "geometry"

melbourne <- asgc2006 %>% 
  filter(MSR_NAME_2006 == "Melbourne") %>%
  select(CD_CODE_2006)

#Load Greater Melbourne CCD codes
areas_of_interest <- load_areas_of_interest(melbourne,  
  area_id_field = "CD_CODE_2006")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


si_CCD2006_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(si_CCD2006_21_census_week, "results/Greater_Melbourne/si_CCD2006_21_census_week.csv")

si_CCD2006_21_census_week <- read_csv("results/Greater_Melbourne/si_CCD2006_21_census_week.csv")

si_CCD2006_21_census_week_aggregated <- si_CCD2006_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(si_CCD2006_21_census_week_aggregated, "results/Greater_Melbourne/si_CCD2006_21_census_week_aggregated.csv")


```


Unfortunately, it is not possible to obtain 
2016 or 2021 social disadvantage data for 
CCDs, as the ABS now releases data for SA zones only. 
SA1 zones, therefore, are adopted for the comparison of 
social needs-gaps in 2016 and 2021, 
as discussed in the following. 

## Variation in spatial patterns across location. 
SI scores were also calculated for 
Greater Melbourne, 
Greater Brisbane, 
Greater Perth, 
Greater Adelaide,
Greater Hobart and 
the Australian Capital Territory (which includes Canberra),
again for the week starting on the day of the 2021 census.
Historical GTFS data was again sourced via the Transit Feeds website, 
Unfortunately it was not possible to locate 
historical GTFS data for Greater Sydney 
or Greater Darwin, 
so instead the latest data sets were sourced directly 
from the relevant transit authorities. 


For comparison between cities, 
Statistical Area 1 (SA1) zones were adopted 
from the Australian Bureau of Statistics [@ABSmaps] 
as the areas of interest. 
This allowed direct comparison 
to ABS-reported values for social and 
transport needs, 
population 
and other census data. 

```{r run_for_all_modes_Greater_Melbourne_210810_SA1, eval = FALSE, echo = FALSE}
list_gtfs = ptv_210805_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Melbourne") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


si_SA12021_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(si_SA12021_21_census_week, "results/Greater_Melbourne/si_SA12021_21_census_week.csv")

si_SA12021_21_census_week <- read_csv("results/Greater_Melbourne/si_SA12021_21_census_week.csv")

si_SA12021_21_census_week_aggregated <- si_SA12021_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(si_SA12021_21_census_week_aggregated, "results/si_SA12021_21_census_week_aggregated.csv")


```


```{r run_for_all_modes_Greater_Brisbane_210810_SA1, eval = FALSE, echo = FALSE}

###The gtfs agency.txt file has been manually edited to add an agency_id field, so that the tidygtfs functions will worl

## convert to list of tidygtfs objects
translink_seq_210805_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/translink_seq_210805/gtfs_edited.zip")



list_gtfs = translink_seq_210805_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Brisbane") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


brisbane_si_SA12021_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(brisbane_si_SA12021_21_census_week, "results/Greater_Brisbane/brisbane_si_SA12021_21_census_week.csv")

brisbane_si_SA12021_21_census_week <- read_csv("results/Greater_Brisbane/brisbane_si_SA12021_21_census_week")

brisbane_si_SA12021_21_census_week_aggregated <- brisbane_si_SA12021_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(brisbane_si_SA12021_21_census_week_aggregated, "results/Greater_Brisbane/brisbane_si_SA12021_21_census_week_aggregated.csv")


```


```{r run_for_all_modes_Greater_Adelaide_210810_SA1, eval = FALSE, echo = FALSE}

###The gtfs agency.txt file has been manually edited to add an agency_id field, so that the tidygtfs functions will worl

## convert to list of tidygtfs objects
adelaide_metro_210716_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/adelaide_metro_210716/gtfs.zip")



list_gtfs = adelaide_metro_210716_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Adelaide") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


adelaide_si_SA12021_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(adelaide_si_SA12021_21_census_week, "results/Greater_Adelaide/adelaide_si_SA12021_21_census_week.csv")

#adelaide_si_SA12021_21_census_week <- read_csv("results/Greater_Adelaide/adelaide_si_SA12021_21_census_week")

adelaide_si_SA12021_21_census_week_aggregated <- adelaide_si_SA12021_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(adelaide_si_SA12021_21_census_week_aggregated, "results/Greater_Adelaide/adelaide_si_SA12021_21_census_week_aggregated.csv")


```
```{r run_for_all_modes_Greater_Hobart_210810_SA1, eval = FALSE, echo = FALSE}

###The gtfs agency.txt file has been manually edited to add an agency_id field, so that the tidygtfs functions will worl

## convert to list of tidygtfs objects
metrotas_hobart_210726_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/metrotas_hobart_210726/gtfs.zip")



list_gtfs = metrotas_hobart_210726_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Hobart") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


hobart_si_SA12021_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(hobart_si_SA12021_21_census_week, "results/Greater_Hobart/hobart_si_SA12021_21_census_week.csv")

#hobart_si_SA12021_21_census_week <- read_csv("results/Greater_Hobart/hobart_si_SA12021_21_census_week")

hobart_si_SA12021_21_census_week_aggregated <- hobart_si_SA12021_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(hobart_si_SA12021_21_census_week_aggregated, "results/Greater_Hobart/hobart_si_SA12021_21_census_week_aggregated.csv")


```

```{r run_for_all_modes_Greater_Perth_210810_SA1, eval = FALSE, echo = FALSE}

###The gtfs agency.txt file has been manually edited to add an agency_id field, so that the tidygtfs functions will worl

## convert to list of tidygtfs objects
transperth_210805_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/transperth_210805/gtfs.zip")



list_gtfs = transperth_210805_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Perth") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


perth_si_SA12021_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(perth_si_SA12021_21_census_week, "results/Greater_Perth/perth_si_SA12021_21_census_week.csv")

#perth_si_SA12021_21_census_week <- read_csv("results/Greater_Perth/perth_si_SA12021_21_census_week")

perth_si_SA12021_21_census_week_aggregated <- perth_si_SA12021_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(perth_si_SA12021_21_census_week_aggregated, "results/Greater_Perth/perth_si_SA12021_21_census_week_aggregated.csv")


```



```{r run_for_all_modes_Greater_Canberra_210810_SA1, eval = FALSE, echo = FALSE}

#Load gtfs for bus and LRT and merge
action_buses_210701 <- gtfstools::read_gtfs("data/action_buses_210701/gtfs.zip") 
canberra_light_rail_210709 <- gtfstools::read_gtfs("data/canberra_light_rail_210709/gtfs.zip") 

canberra_gtfs_merged_2107 <- gtfstools::merge_gtfs(action_buses_210701, canberra_light_rail_210709)

gtfstools::write_gtfs(canberra_gtfs_merged_2107, "data/canberra_gtfs_merge_2107/gtfs.zip")

## convert to list of tidygtfs objects
canberra_merged_2107_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/canberra_gtfs_merge_2107/gtfs.zip")



list_gtfs = canberra_merged_2107_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(state_name_2021 == "Australian Capital Territory") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


canberra_si_SA12021_21_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2021-08-10", 
 end_date_ymd = "2021-08-16",
verbose = TRUE)

write.csv(canberra_si_SA12021_21_census_week, "results/Greater_Canberra/canberra_si_SA12021_21_census_week.csv")

#canberra_si_SA12021_21_census_week <- read_csv("results/Greater_Canberra/canberra_si_SA12021_21_census_week")

canberra_si_SA12021_21_census_week_aggregated <- canberra_si_SA12021_21_census_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(canberra_si_SA12021_21_census_week_aggregated, "results/Greater_Canberra/canberra_si_SA12021_21_census_week_aggregated.csv")


```




```{r run_for_all_modes_Darwin_240806_SA1, eval = FALSE, echo = FALSE}

## convert to list of tidygtfs objects
darwin_240607_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/darwin_240607/google-transit-darwin-20240607.zip")



list_gtfs = darwin_240607_list_gtfs 

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Darwin") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


darwin_si_SA12021_240806_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2024-08-06", 
 end_date_ymd = "2024-08-12",
verbose = TRUE)

write.csv(darwin_si_SA12021_240806_week, "results/Greater_Darwin/darwin_si_SA12021_240806_week.csv")


darwin_si_SA12021_240806_week_aggregated <- darwin_si_SA12021_240806_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(darwin_si_SA12021_240806_week_aggregated, "results/Greater_Darwin/darwin_si_SA12021_240806_week_aggregated.csv")


```

```{r run_for_all_modes_Sydney_240806_SA1, eval = FALSE, echo = FALSE}
# Revise routes.txt to remove extended route types
# Outside of R extracted the gtfs.zip
routes <- read_csv("data/sydney_240607/full_greater_sydney_gtfs_static_0/routes.csv")

routes_revised <- routes %>% 
    mutate(route_type = replace(route_type, route_type == 714, 3)) %>% 
    mutate(route_type = replace(route_type, route_type == 700, 3)) %>% 
    mutate(route_type = replace(route_type, route_type == 712, 3)) %>% 
    mutate(route_type = replace(route_type, route_type == 401, 1)) %>% 
    mutate(route_type = replace(route_type, route_type == 204, 3)) %>% 
    mutate(route_type = replace(route_type, route_type == 106, 2)) %>% 
    mutate(route_type = replace(route_type, route_type == 205, 3)) %>% 
    mutate(route_type = replace(route_type, route_type == 900, 0)) 


write.csv(routes_revised, "data/sydney_240607/full_greater_sydney_gtfs_static_0/routes.csv")

# Outside of R renamed routes.csv to routes.txt and zipped the gtfs feed back up again
  

## convert to list of tidygtfs objects
sydney_240607_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/sydney_240607/gtfs_revised.zip")



list_gtfs = sydney_240607_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Sydney") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

buffer_distance <- gtfssupplyindex:::load_buffer_zones()

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)


sydney_si_SA12021_240806_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2024-08-06", 
 end_date_ymd = "2024-08-12",
verbose = TRUE)

write.csv(sydney_si_SA12021_240806_week, "results/Greater_Sydney/sydney_si_SA12021_240806_week.csv")


sydney_si_SA12021_240806_week_aggregated <- sydney_si_SA12021_240806_week %>% 
           group_by(area_id) %>%    
           summarize(SI = sum(SI))

write.csv(sydney_si_SA12021_240806_week_aggregated, "results/Greater_Sydney/sydney_si_SA12021_240806_week_aggregated.csv")


```






## Variation in time

SHOULD THIS BE RUN FOR ALL YEARS AS FAR BACK AS THE GTFS DATA GOES??


```{r fix_ptv_data_Victoria_160804, eval = FALSE, echo = FALSE}
 

ptv_160804 <- tidytransit::read_gtfs("data/ptv_160804/gtfs.zip")
# This results in "Warning: Duplicated ids found in: stops The returned object is not a tidygtfs object, you can use as_tidygtfs() after fixing the issue."

#So, remove the duplicated stops 
#identify duplicate stops
ptv_160804_duplicated_stops <- tabyl(ptv_160804$stops$stop_id) %>% filter (n>1)
names(ptv_160804_duplicated_stops) <- c("stop_id", "n", "percent")
ptv_160804_duplicated_stops <- left_join(ptv_160804_duplicated_stops, ptv_160804$stops)

##discard duplicates
ptv_160804$stops <- ptv_160804$stops[!duplicated(ptv_160804$stops$stop_id),]

## Write gtfs back to file
ptv_160804 <- as_tidygtfs(ptv_160804)
tidytransit::write_gtfs(ptv_160804, "data/ptv_160804/gtfs_duplicate_stops_removed.zip")

## convert to list of tidygtfs objects
ptv_160804_list_gtfs <- gtfssupplyindex::gtfs_by_route_type("data/ptv_160804/gtfs_duplicate_stops_removed.zip")

```


```{r run_for_all_modes_Victoria_160809, eval = FALSE, echo = FALSE}
list_gtfs = ptv_160804_list_gtfs

areas_of_interest <- load_areas_of_interest(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Melbourne") %>%
    select(sa1_code_2021),  
  area_id_field = "sa1_code_2021")

stops_in_or_near_areas <- gtfssupplyindex:::stops_in_walk_dist(
  list_gtfs = list_gtfs, 
  areas_of_interest = areas_of_interest,
  EPSG_for_transform = 28355,
  verbose = FALSE
)



si_SA12021_16_census_week <- SI_by_day_hour_and_route_type(
     list_gtfs = list_gtfs, 
stops_in_or_near_areas = stops_in_or_near_areas,
 start_date_ymd = "2016-08-09", 
 end_date_ymd = "2021-08-15",
verbose = TRUE)

write.csv(si_SA12021_16_census_week, "results/Greater_Melbourne/si_SA12021_16_census_week")

```


## Measuring social disadvantage
This study adopts a similar approach to measuring social disadvantage 
as used in @currie2010identifying, using: 
the ABS' Index of Relative Socio-Economic Advantage/Disadvantage (IRSAD); and
a transport needs index^[The same need indicators and weightings used in @currie2010identifying were adopted, although
\$799 or lower per week was used
as the  threshold for low income households 
rather than \$499 
to account for inflation 
(as per Reserve Bank of Australia's online inflation calculator).].
A composite needs indicator was derived 
based on the IRSAD and the transport needs index, 
again as per the @currie2010identifying approach^[However, 
changes to the ABS reporting systems mean
that the composite needs indicator 
had to based on weighting both the IRSAD index and the transport need index 
by the total population of each SA1 zone, 
which were then added, standardised and split into six groups.]. 


```{r read_ABS_data, fig.show="hold", echo = FALSE, warning=FALSE, message=FALSE, cache=TRUE, fig.fullwidth = TRUE, fig.cap="SI scores by SA3, census day 2016 and 2021"}

#read IRSAD 2021 and remove non-data rows
sa1_irsad_2021 <- read_excel("data/Statistical Area Level 1, Indexes, SEIFA 2021.xlsx", 
    sheet = "Table 3", skip = 5)
sa1_irsad_2021 <- sa1_irsad_2021 %>% filter(row_number() <= n()-3)
sa1_irsad_2021 <- sa1_irsad_2021 %>% 
  clean_names()

#read students 2021 and remove non-data rows
sa1_students_2021 <- read_csv("data/sa1_students.csv", 
    skip = 8)
sa1_students_2021 <- sa1_students_2021[-1,]
sa1_students_2021 <- sa1_students_2021 %>% filter(row_number() <= n()-5)

#read not in labour force in 2021 and remove non-data rows
#this dataset contains a single 'wafer', 
# being those people not in the labour force, separated by age and sa1
sa1_not_in_labour_force_2021 <- read_csv("data/sa1_not_in_labour_force_2021.csv", 
    skip = 10)
sa1_not_in_labour_force_2021 <- sa1_not_in_labour_force_2021[-1,]
#not_in_labour_force csv from ABS repeats the entire dataset, hence only read in first set
sa1_not_in_labour_force_2021 <- sa1_not_in_labour_force_2021 %>% filter(row_number() <= n()-61844)


#calculate number of adults not in labour force (ie 18+)
sa1_not_in_labour_force_2021$adult_not_labour_force <- rowSums (sa1_not_in_labour_force_2021[,20:117])
  



#read no car in 2021 and remove non-data rows
#this dataset contains a single 'wafer', 
# being those people living in a household with no car, separated by age and sa1
sa1_no_car_2021 <- read_csv("data/sa1_no_car_2021.csv", 
    skip = 8)
sa1_no_car_2021 <- sa1_no_car_2021[-1,]
sa1_no_car_2021 <- sa1_no_car_2021 %>% filter(row_number() <= n()-5)
#calculate number of adults with no car (ie 18+)
sa1_no_car_2021$adult_no_car <- rowSums(sa1_no_car_2021[,20:117])


#read low income in 2021 and remove non-data rows
sa1_low_income_2021 <- read_csv("data/sa1_low_income.csv", 
    skip = 8)
sa1_low_income_2021 <- sa1_low_income_2021[-1,]
sa1_low_income_2021 <- sa1_low_income_2021 %>% filter(row_number() <= n()-5)

#read disability support pension in 2021 and remove non-data rows
sa1_disability_support_pension_2021 <- read_csv("data/sa1_disability_2021.csv", 
    skip = 8)
sa1_disability_support_pension_2021 <- sa1_disability_support_pension_2021[-1,]
sa1_disability_support_pension_2021 <- sa1_disability_support_pension_2021 %>% filter(row_number() <= n()-5)




#read age in 2021 and remove non-data rows
sa1_age_2021 <- read_csv("data/sa1_age.csv", 
    skip = 8)
sa1_age_2021 <- sa1_age_2021[-1,]
sa1_age_2021 <- sa1_age_2021 %>% filter(row_number() <= n()-5)

#calculate number of people over 60.
sa1_age_2021$over_60 <- rowSums(sa1_age_2021[,63:117])

#calculate number of persons 5 to 9 years old.
sa1_age_2021$persons_5_to_9 <- rowSums(sa1_age_2021[,7:11]) 
#move age-related indicators into social indicators table. 
social_2021_sa1 <- sa1_age_2021 %>% 
  select(`AGEP Age`, over_60, persons_5_to_9)
names(social_2021_sa1) <- c("sa1_code_2021", "over_60", "five_to_nine")

#join Adults without Cars
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_no_car_2021 %>% 
                               select("AGEP Age", "adult_no_car"), 
                             by = join_by( "sa1_code_2021" == "AGEP Age"))

#join disability pension 
sa1_disability_support_pension_2021 <-  sa1_disability_support_pension_2021 %>% 
  clean_names()
  
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_disability_support_pension_2021 %>% 
                               select(
                                 "igap_main_type_of_personal_government_benefit_payment_administrative_data", 
                                      "disability_support_pension"),
                             by = join_by(
                               "sa1_code_2021" == "igap_main_type_of_personal_government_benefit_payment_administrative_data"))



#join low income households
sa1_low_income_2021$low_income_families <- rowSums(sa1_low_income_2021[,2:9])
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_low_income_2021 %>% 
                               select("FINASF Total Family Income as Stated (weekly)", "low_income_families"), 
                             by = join_by( "sa1_code_2021" == "FINASF Total Family Income as Stated (weekly)"))


#join adults not in labour force
social_2021_sa1 <- full_join(social_2021_sa1 %>% na.omit(), 
                             sa1_not_in_labour_force_2021 %>% 
                               select("AGEP Age", "adult_not_labour_force") %>%
                               na.omit(), 
                             by = join_by("sa1_code_2021" == "AGEP Age"))

#join students
sa1_students_2021$students <- sa1_students_2021$Total
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_students_2021 %>% 
                               select("STUP Full-Time/Part-Time Student Status", "students"), 
                             by = join_by( "sa1_code_2021" == "STUP Full-Time/Part-Time Student Status"))

#join IRSAD scores
sa1_irsad_2021$x2021_statistical_area_level_1_sa1 <- sa1_irsad_2021$x2021_statistical_area_level_1_sa1 %>% 
  as.character()
names(sa1_irsad_2021) <- c("sa1_code_2021", 
                           "usual_resident_population",
                           "IRSAD", 
                           "x4", 
                           "rank_in_australia", 
                           "decile_in_australia",
                           "percentile_in_australia", 
                           "x8", 
                           "state", 
                           "rank_in_state",
                           "decile_in_state",
                           "percentile_in_state")

social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_irsad_2021 %>% 
                               select("sa1_code_2021", "IRSAD"))


#join SA1 enumerated population
social_2021_sa1 <- full_join(social_2021_sa1, 
                             sa1_age_2021 %>% 
                               select("AGEP Age", "Total"), 
                             by = join_by("sa1_code_2021" == "AGEP Age"))

names(social_2021_sa1) <- c("sa1_code_2021", 
                            "over_60", "age_five_to_nine", 
                            "adult_no_car", 
                            "disability_support_pension",
                            "low_income_families",
                            "adult_not_labour_force",
                            "students", 
                            "IRSAD", 
                            "population")

##Rescaling to 0-100 and adding the accessibility indicator needs to be done on a areas_of_interest by areas_of_interest bias, as which areas are included will matter. 

```


# Results
## The gtfssupplyindex Package
Code developed to calculate SI scores 
is available as an R package on github (see @gtfssupplyindex_github).
Included in the package 
is a vignette that outlines 
the structure of the calculations, 
the developed functions (LINK HERE), 
and step-by-step calculations for the 
Mornington Peninsula Railway 
as a worked example 
and comparison to SI scores calculated manually.  

## Greater Melbourne: changes since 2006 
### 2021 SI scores - CCDs 


```{r Greater_Melbourne_CCD_2021, fig.show="hold", out.width="100%", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.cap="Greater Melbourne (2006 extents), Transport Supply by CCD, week starting the day of the 2021 census"}

## FUNCTION to define thresholds and return Very High, High etc. 
# as per Currie2010 Table 3 and page 34. 
# the approach appears to be to first identify zones that have zero supply 
# the remainder are then split into those above and below the average SI value
# these two groups are then each split into three groups of roughly equal size. 
set_thresholds <-function(si_by_area_dataframe){ 

## Define Very High, High etc thresholds
cuts_lower_groups <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI <= SI %>% mean()) %>% 
  select(SI) %>% unlist() %>% 
  as.vector() %>% 
  quantileCut(3)

cuts_upper_groups <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI > SI %>% mean()) %>%
  select(SI) %>% unlist() %>% 
  as.vector() %>% 
  quantileCut(3)

# Recode lower_group factors
allocation_lower_groups <- cuts_lower_groups %>% fct_recode(
  "Very Low" = levels(cuts_lower_groups)[1], 
  "Low" = levels(cuts_lower_groups)[2], 
  "Below average" = levels(cuts_lower_groups)[3])

# Recode upper_group factors
allocation_upper_groups <- cuts_upper_groups %>% fct_recode(
  "Above average" = levels(cuts_upper_groups)[1], 
  "High" = levels(cuts_upper_groups)[2], 
  "Very High" = levels(cuts_upper_groups)[3])


# Join back to lower_group SIs and areas_of_interest
si_by_area_dataframe_below_average <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI <= SI %>% mean()) 
si_by_area_dataframe_below_average$transit_supply <- allocation_lower_groups

# Join back to upper_group SIs and areas_of_interest
si_by_area_dataframe_above_average <- si_by_area_dataframe %>% 
  st_drop_geometry() %>% 
  filter(SI !=0) %>%
  filter(SI > SI %>% mean()) 
si_by_area_dataframe_above_average$transit_supply <- allocation_upper_groups

# combine upper and lower groups
  
si_by_area_dataframe_non_zero <- add_row(si_by_area_dataframe_below_average, 
                                         si_by_area_dataframe_above_average)

#join back to dataframe, and put "Zero" in N/A
si_by_area_dataframe <- full_join(
  si_by_area_dataframe %>% 
    st_drop_geometry(), 
  si_by_area_dataframe_non_zero
)

si_by_area_dataframe$transit_supply <- si_by_area_dataframe$transit_supply %>% 
  fct_explicit_na(na_level = "Zero Supply") %>% 
  fct_shift(n = -1)

#return dataframe and information about level cut offs
si_by_area_dataframe_and_cuts_dataframe <- list(
  si_by_area_dataframe,
  c(levels(cuts_lower_groups), levels(cuts_upper_groups))
  )
return(si_by_area_dataframe_and_cuts_dataframe)
}
# END FUNCTION

## FUNCTION to set thresholds and return tibble, plot output and thresholds
si_thresholds_and_plot_function <- function(si_by_area, areas_of_interest){
# Set column names
names(si_by_area) <- c("area_id", "SI")
names(areas_of_interest) <- c("area_id", "geometry")
  
si_by_area$area_id <- si_by_area$area_id %>% 
  as.character()


##Join to areas_of_interest so as to identify (and enumerate as zero) 
# those areas of interest that have no SI score 

si_by_area <- full_join(
  areas_of_interest,
  si_by_area)
si_by_area[is.na(si_by_area)] <- 0

si_by_area_thresholds <- set_thresholds(si_by_area_dataframe = si_by_area)
si_by_area <- si_by_area_thresholds[[1]]


si_by_area <- left_join(
  areas_of_interest, 
  si_by_area)

output_plot <- ggplot()+ 
  geom_sf(data=si_by_area %>% na.omit(),
          aes(fill = transit_supply), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="bottom",
        legend.text = element_text(size = 4), 
        legend.title = element_text(size = 5)) + 
  scale_fill_manual(values = c("#FFFFFF", "#F9D8B1", "#F7C387", "#F29C33", "#5DB000", "#53A212", "#407F0B")) 


###NEED TO ADD SCALE, NORTH ARROW AND INNER, MIDDLE, OUTER boundaries.  CONSIDER ADDING TRAIN LINES AND 2006 GREATER MELBOURNE BOUNDARY

  outputs <- list("si_by_area" = si_by_area, 
                  "output_plot" = output_plot, 
                  "thresholds" = si_by_area_thresholds[[2]])
  return(outputs)
}

si_by_area <- read.csv("results/Greater_Melbourne/si_CCD2006_21_census_week_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]

asgc2006 <- st_read("data/asgc2006.gpkg", layer = "census_collection_district_2006", quiet = TRUE)
st_geometry(asgc2006) <- "geometry"

melbourne_CCD <- asgc2006 %>% 
  filter(MSR_NAME_2006 == "Melbourne") %>%
  select(CD_CODE_2006)
areas_of_interest <- melbourne_CCD

si_CCD2006_21_census_week_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

# Load 2006 Melbourne boundary
melbourne_sd07aust_region <- st_read("data/1259030001sd07 aust/") %>% 
  filter(SDNAME07 == "Melbourne")

# Load 2006 LGA boundaries
vic_lga07aust_region <- st_read("data/1259030001lga07 aust/") %>% 
                                  filter(STATE07 == 2)

# Set boundaries between around middle suburbs       
middle_lga07aust_region <- vic_lga07aust_region[
  vic_lga07aust_region$LGANAME07 %in% 
    c("Banyule (C)", "Bayside (C)", "Boroondara (C)", "Brimbank (C)", 
      "Darebin (C)", "Glen Eira (C)", "Greater Dandenong (C)", 
      "Hobsons Bay (C)", "Kingston (C)", "Manningham (C)", 
      "Maribyrnong (C)", "Monash (C)", "Moonee Valley (C)", 
      "Moreland (C)", "Stonnington (C)","Whitehorse (C)"), ] 
middle_lga07aust_region <- st_union(middle_lga07aust_region)

# plot with inner, middle and outer boundaries
si_CCD2006_21_census_week_aggregated$output_plot + 
  geom_sf(data=melbourne_sd07aust_region, fill = NA, linewidth = 1) +
  geom_sf(data=middle_lga07aust_region, fill = NA, linewidth = 0.75)
```

Figure \ref{fig:Greater_Melbourne_CCD_2021} shows SI scores 
for Melbourne in the week of the 2021 census, 
using the same (2006) CCD boundaries as shown in Figure \ref{fig:Currie_map_SI}.
Comparing Figures \ref{fig:Currie_map_SI} 
and \ref{fig:Greater_Melbourne_CCD_2021} suggests: 

- Overall spatial patterns appear generally similar in 2021 as in 2006, with higher levels of transit supply in inner areas and close to most railway lines.
- There are still many areas with very low or zero transit supply, especially in outer areas. However, only `r si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>%  filter(transit_supply == "Zero Supply") %>% nrow()` CCDs have Zero Supply in 2021, compared to the 186 in 2006 reported in @currie2010identifying. 
- There are, however, slightly more CCDs included in this 2021 analysis (`r si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>% nrow() %>% format(big.mark = ",")` compared to the 5,720 in 2006), meaning that the percentage of CCDs with Zero Supply has fallen to `r percent_format(accuracy = 0.01)((si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>%  filter(transit_supply == "Zero Supply") %>%  nrow()) / (si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>% nrow()))` from the 3.25% in 2006. The average SI value has also increased to `r si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>% select(SI) %>% st_drop_geometry() %>% unlist()%>% mean() %>% format(big.mark = ",", digits = 5)` from its value of 2,886.9 in 2006, indicating that the overall transit service supply score has increased by approximately `r percent_format(accuracy = 1)((si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>% select(SI) %>% st_drop_geometry() %>% unlist() %>% mean() * si_CCD2006_21_census_week_aggregated[["si_by_area"]] %>% nrow()) / (2886.9 * 5839)-1)`.


```{r Greater_Melbourne_CCD_2021_by_suburbs, fig.show="hold", out.width="100%", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.cap="Greater Melbourne (2006 extents), SI score by CCD, week starting the day of the 2021 census, inner, middle and outer suburbs"}

#build table with inner, middle and outer
si_CCD2006_21_census_week_aggregated_middle_suburbs <- si_CCD2006_21_census_week_aggregated$si_by_area %>% st_filter(middle_lga07aust_region, .predicate = st_intersects)
si_CCD2006_21_census_week_aggregated_middle_suburbs$suburbs <- "middle"



outer_lga07aust_region <- vic_lga07aust_region[
  vic_lga07aust_region$LGANAME07 %in% c(
    "Cardinia (S)", "Casey (C)", "Frankston (C)", "Hume (C)", "Knox (C)", 
    "Mornington Peninsula (S)", "Maroondah (C)", "Melton (S)", "Nillumbik (S)", 
    "Whittlesea (C)", "Wyndham (C)", "Yarra Ranges (S)"),] 
outer_lga07aust_region <- st_union(outer_lga07aust_region)
si_CCD2006_21_census_week_aggregated_outer_suburbs <- si_CCD2006_21_census_week_aggregated$si_by_area %>% st_filter(outer_lga07aust_region, .predicate = st_intersects)
si_CCD2006_21_census_week_aggregated_outer_suburbs$suburbs <- "outer"

# Set boundaries between around inner suburbs       
inner_lga07aust_region <- vic_lga07aust_region[
  vic_lga07aust_region$LGANAME07 %in% 
    c("Melbourne (C)", "Yarra (C)", "Port Phillip (C)"),]
inner_lga07aust_region <- st_union(inner_lga07aust_region)


inner_lga07aust_region <- st_union(inner_lga07aust_region)
si_CCD2006_21_census_week_aggregated_inner_suburbs <- si_CCD2006_21_census_week_aggregated$si_by_area %>% st_filter(inner_lga07aust_region, .predicate = st_intersects)
si_CCD2006_21_census_week_aggregated_inner_suburbs$suburbs <- "inner"


# combine outer and middle
si_CCD2006_21_census_week_aggregated_outer_and_middle_suburbs <- add_row(
  si_CCD2006_21_census_week_aggregated_outer_suburbs,
  si_CCD2006_21_census_week_aggregated_middle_suburbs)
  
# CCDs that are within both the middle and outer suburbs (ie. on the boundary) 
# Lets assign them to the out
# so drop the duplicated rows
si_CCD2006_21_census_week_aggregated_outer_and_middle_suburbs <- si_CCD2006_21_census_week_aggregated_outer_and_middle_suburbs %>%
  arrange(area_id, rev(suburbs)) %>%
  filter(duplicated(area_id) == FALSE)


# combine inner with outer and middle
si_CCD2006_21_census_week_aggregated$si_by_area <- add_row(
  si_CCD2006_21_census_week_aggregated_outer_and_middle_suburbs,
  si_CCD2006_21_census_week_aggregated_inner_suburbs)
  
# CCDs that are within both the inner and middle suburbs (ie. on the boundary) 
# Lets assign them to the inner
# so drop the duplicated rows
si_CCD2006_21_census_week_aggregated_outer_and_middle_suburbs <- si_CCD2006_21_census_week_aggregated_outer_and_middle_suburbs %>%
  arrange(area_id, suburbs) %>%
  filter(duplicated(area_id) == FALSE)


#ggplot() +
#  geom_sf(data=si_CCD2006_21_census_week_aggregated$si_by_area, 
#aes(fill = suburbs)) +
#  geom_sf(data=middle_lga07aust_region, fill = NA, linewidth = 0.75)

si_CCD2006_21_census_week_aggregated$si_by_area %>%
  st_drop_geometry() %>%
  tabyl(transit_supply, suburbs) %>% 
  adorn_totals(where = c("row", "col")) %>% 
  adorn_percentages() %>% 
  adorn_pct_formatting() %>% 
  adorn_ns() %>% 
  kable(
    caption = "Distribtuion of Transit Supply grouping across inner, middle and outer suburbs",
    align = "lrrr"
  )

si_CCD2006_21_census_week_aggregated$si_by_area %>%
  st_drop_geometry() %>%
  tabyl(transit_supply, suburbs) %>%
  pivot_longer(
    cols = 2:4,
    names_to = "suburb",
    values_to = "CCDs"
  ) %>% 
  ggbarstats(
    y = suburb, 
    x = transit_supply,
    counts = CCDs
  )



```

Table \ref{tab:Greater_Melbourne_CCD_2021_by_suburbs} and Figure \ref{fig:Greater_Melbourne_CCD_2021_by_suburbs}  compares the distribution of Transport Supply groupings across the inner, middle and outer suburbs. In general, the results meet expectations, with a greater proportion of CCDs having higher transit supply in inner and (then) middle surburbs. 

 

```{r Greater_Melbourne_CCD_2021_by_suburbs_SI_scores, fig.show="hold", out.width="100%", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.cap="Greater Melbourne (2006 extents), SI score by CCD, week starting the day of the 2021 census, inner, middle and outer suburbs"}


ggbetweenstats(data = si_CCD2006_21_census_week_aggregated$si_by_area,
               x = suburbs,
               y = SI)
  
```

Figure \ref{fig:Greater_Melbourne_CCD_2021_by_suburbs_SI_scores} compare SI scores for CCDs across the inner, middle and outer suburbs. SI scores average `r si_CCD2006_21_census_week_aggregated$si_by_area %>% st_drop_geometry() %>% filter(suburbs == "inner") %>% select(SI) %>% unlist() %>% mean() %>% format(big.mark = ",", digits = 6)`, `r si_CCD2006_21_census_week_aggregated$si_by_area %>% st_drop_geometry() %>% filter(suburbs == "middle") %>% select(SI) %>% unlist() %>% mean() %>% format(big.mark = ",", digits = 5)` and `r si_CCD2006_21_census_week_aggregated$si_by_area %>% st_drop_geometry() %>% filter(suburbs == "outer") %>% select(SI) %>% unlist() %>% mean() %>% format(big.mark = ",", digits = 4)` for the inner, middle and outer suburbs respectively, compared to scores of 10,922.7, 2,694.9 and 764.3 for 2006 [@currie2010identifying].

### 2021 SI scores - SA1s
The 2006 census was the last one that used CCDs, and population and other census data is now available from the ABS for SA1 zones instead. Figure \ref{fig:Greater_Melbourne_SA1_2021_plot}(Appendix A) shows 2021 SI scores for Greater Melbourne, but using SA1 zones and the 2021 Greater Melbourne GCCSA boundary. Table \ref{tab:Greater_Melbourne_SA1_2021_table} and Figure \ref{fig:Greater_Melbourne_SA1_2021_table} compare number of CCD and SA1 zones in each category in 2006 and 2021. 


```{r Greater_Melbourne_SA1_2021_table, fig.show="hold", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Greater Melbourne: distribution of supply index scores, 2006 CCDs, 2021 CCDs and 2021 SA1s"}


## 2021 Greater Melbourne
si_by_area <-  read.csv( "results/Greater_Melbourne/si_SA12021_21_census_week_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]

areas_of_interest <-  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Melbourne") %>% 
    select(sa1_code_2021)

melbourne_si_SA12021_21_census_week_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

# create comparison table
melbourne_comparison_2006_2021 <- si_CCD2006_21_census_week_aggregated$si_by_area %>% 
  st_drop_geometry() %>%
  tabyl(transit_supply) %>%
  select(transit_supply)

melbourne_comparison_2006_2021$ccds_2006 <- c(
  189, 
  1314, 
  1310,
  1294,
  608,
  535,
  589)

melbourne_comparison_2006_2021$population_2006 <- c(
  85423,
  793046,
  865330, 
  774521,
  324546,
  260411,
  263832)
  
melbourne_comparison_2006_2021$ccds_2021 <- 
  si_CCD2006_21_census_week_aggregated$si_by_area %>% 
  st_drop_geometry() %>% 
  select(transit_supply) %>% 
  table() %>% 
  as_tibble() %>%
  select(n) %>%
  unlist() %>%
  as.numeric()
  
names(melbourne_comparison_2006_2021) <- c(
"transit_supply",
"ccds_2006", 
"population_2006", 
"ccds_2021")

melbourne_comparison_2006_2021$sa1s_2021 <- melbourne_si_SA12021_21_census_week_aggregated$si_by_area %>% 
  st_drop_geometry() %>% 
  select(transit_supply) %>% 
  table() %>% 
  as_tibble() %>%
  select(n) %>%
  unlist() %>%
  as.numeric()

names(melbourne_comparison_2006_2021) <- c(
"transit_supply",
"ccds_2006", 
"population_2006", 
"ccds_2021", 
"sa1s_2021")

# load and cleanup 2021 population by sa1
sa1_ur_agep_2021 <- read_csv("data/sa1_ur_agep_2021.csv", 
    skip = 8)
sa1_ur_agep_2021 <- sa1_ur_agep_2021[-1,]
sa1_ur_agep_2021 <- sa1_ur_agep_2021[1:61845,1:118] 
sa1_ur_agep_2021 <- sa1_ur_agep_2021%>% type.convert(as.is = T)
sa1_ur_agep_2021 <- sa1_ur_agep_2021 %>% clean_names()
colnames(sa1_ur_agep_2021)[colnames(sa1_ur_agep_2021) == "agep_age"] <- "sa1_code_2021"
#check variable types
#lapply(sa1_ur_agep_2021, class) %>% as_vector() %>% tabyl()

# connect population to transit supply
population_sa1_greater_melbourne <- left_join(
  areas_of_interest %>% st_drop_geometry(), 
  sa1_ur_agep_2021 %>% select(sa1_code_2021, total))

population_sa1_greater_melbourne <- left_join(
  melbourne_si_SA12021_21_census_week_aggregated$si_by_area %>% 
    st_drop_geometry() %>%
    select(area_id, transit_supply), 
  population_sa1_greater_melbourne, 
  join_by(area_id == sa1_code_2021)
  )
names(population_sa1_greater_melbourne) <- c("sa1_code_2021", 
                                             "transit_supply", 
                                             "population")


# add to comparison table
melbourne_comparison_2006_2021$population_2021 <- population_sa1_greater_melbourne %>% aggregate(population ~ transit_supply, sum) %>% 
  select(population) %>% 
  as_tibble() %>%
  unlist() %>%
  as.numeric()

names(melbourne_comparison_2006_2021) <- c(
"transit_supply",
"ccds_2006", 
"population_2006", 
"ccds_2021", 
"sa1s_2021", 
"population_2021")


melbourne_comparison_2006_2021 %>% 
  select(transit_supply, ccds_2006, ccds_2021, sa1s_2021, population_2006, population_2021) %>%
  as_tibble() %>% 
  adorn_totals() %>%
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns() %>% 
  kable( 
      caption = "Greater Melbourne: Distribution of supply index scores and resident population. Sources: 2006 values (Currie 2010), 2021 values (authors)",
      align = "lrrrrr",
      col.names = c("category", 
                   "2006", "2021", "2021",
                   "2006", "2021")
      ) %>% 
  add_header_above(c("Supply Index" =1, "CCDs" = 2, "SA1s" = 1, "Population" = 2))

ggbarstats(melbourne_comparison_2006_2021 %>% 
             select(transit_supply, ccds_2006, ccds_2021, sa1s_2021) %>% 
             pivot_longer(
    cols = 2:4,
    names_to = "areas_of_interest", 
    values_to = "counts"),
  x = transit_supply, 
  y = areas_of_interest, 
  counts = "counts")
  
  
    
```

A smaller proportion of CCDs have Zero Supply in 2021 than 2006, suggesting that transit now covers more of city. However, Greater Melbourne now covers a larger spatial area than it did in 2006, and most of the new additions appear to have Zero or Very Low transit supply. Hence, looking at the overall picture for 2021 the proportion of SA1s with Zero Supply or with supply below the average is larger than was the case for CCDs in 2006.  


```{r Greater_Melbourne_population_figure, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.cap="Greater Melbourne: population distribution of supply index scores. Sources: 2006 values (Currie2010), 2021 values (authors)"}

names(melbourne_comparison_2006_2021) <- c("transit_supply", 
                                           "ccds_2006", 
                                           "2006", 
                                           "ccds_2021", 
                                           "sa1s_2021", 
                                           "2021")

ggbarstats(melbourne_comparison_2006_2021 %>% 
             select(transit_supply, `2006`, `2021`) %>% 
             pivot_longer(
    cols = 2:3,
    names_to = "year", 
    values_to = "population"),
  x = transit_supply, 
  y = year, 
  counts = population)

names(melbourne_comparison_2006_2021) <- c("transit_supply", "ccds_2006", "population_2006", "ccds_2021", "sa1s_2021", "population_2021")
 
```


Table \ref{tab:Greater_Melbourne_SA1_2021_table} and Figure \ref{fig:Greater_Melbourne_population_figure} show that the proportion of the population in zones with Zero Supply was higher in 2021 than in 2006.  but a slightly larger share of the population are in zones with SI scores above the average. 

### 2021 Social needs
Figure \ref{fig:Greater_Melbourne_2021_social_needs} shows the distribution of categories of social need index scores across Greater Melbourne for 2021. This figure is analogous to the 2006 value from @currie2010identifying shown in Figure \ref{fig:Currie_map_needs} although, as discussed in the methodology section above, it was not possible to exactly replicate the @currie2010identifying approach due to changes in the way census results are reported. 

```{r Greater_Melbourne_2021_social_needs, out.width="90%", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE,  fig.cap="Distribution of categories of composite social need index scores, with 2006 Melbourne boundary shown in black. Source: authors analysis of ABS data"}

#join to sa1 data, including lat and long of each sa1
social_2021_sa1_greater_melbourne <- left_join(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Melbourne") %>% 
    select(sa1_code_2021, sa3_name_2021, cent_lat, cent_long) %>%
    st_drop_geometry(),
  social_2021_sa1 
)

# from https://stackoverflow.com/questions/36817423/how-to-efficiently-calculate-distance-between-pair-of-coordinates-using-data-tab/42014364#42014364
dt.haversine <- function(lat_from, lon_from, lat_to, lon_to, r = 6378137){
  radians <- pi/180
  lat_to <- lat_to * radians
  lat_from <- lat_from * radians
  lon_to <- lon_to * radians
  lon_from <- lon_from * radians
  dLat <- (lat_to - lat_from)
  dLon <- (lon_to - lon_from)
  a <- (sin(dLat/2)^2) + (cos(lat_from) * cos(lat_to)) * (sin(dLon/2)^2)
  return(2 * atan2(sqrt(a), sqrt(1 - a)) * r)
}

social_2021_sa1_greater_melbourne$distance_m_to_GPO <- 
 dt.haversine(-37.813840, 
              144.963028,
              social_2021_sa1_greater_melbourne$cent_lat,
              social_2021_sa1_greater_melbourne$cent_long)


calculate_IRSAD_and_need_index <- function(social_dataset) {
  # scale all to 0 to 100
  social_dataset$IRSAD_100 <- rescale_max(
     social_dataset$IRSAD, to = c(0, 100))
  social_dataset$adult_no_car_100 <- rescale_max(
    social_dataset$adult_no_car, to = c(0, 100))
   social_dataset$accessibility_100 <- rescale_max(
     social_dataset$distance_m_to_GPO, to = c(0, 100))
   social_dataset$over_60_100 <- rescale_max(
     social_dataset$over_60, to = c(0, 100))
   social_dataset$disability_pension_100 <- rescale_max(
     social_dataset$disability_support_pension, to = c(0, 100))
   social_dataset$low_income_families_100 <- rescale_max(
     social_dataset$low_income_families, to = c(0, 100))
  social_dataset$adult_not_labour_force_100 <- rescale_max(
     social_dataset$adult_not_labour_force, to = c(0, 100))
  social_dataset$students_100 <- rescale_max(
     social_dataset$students, to = c(0, 100))
  social_dataset$age_five_to_nine_100 <- rescale_max(
     social_dataset$age_five_to_nine, to = c(0, 100))
  
  # calculate needs scores and scale to 100
  social_dataset$needs_score <- social_dataset$adult_no_car_100 * 0.19 +
    social_dataset$accessibility_100 * 0.15 + 
    social_dataset$over_60_100 * 0.14 + 
    social_dataset$disability_pension_100 * 0.12 + 
    social_dataset$low_income_families_100 * 0.10 + 
    social_dataset$adult_not_labour_force_100 * 0.09 + 
    social_dataset$students_100 * 0.09 + 
    social_dataset$age_five_to_nine_100 * 0.12
  social_dataset$needs_score_100 <- rescale_max(
     social_dataset$needs_score, to = c(0, 100))
  
  # weight IRSAD and needs score by total population
  social_dataset$total_need_IRSAD <- social_dataset$IRSAD *
    social_dataset$population
  social_dataset$total_transport_need <- social_dataset$needs_score * 
    social_dataset$population
  
  # create combined indicator 0 to 100
  social_dataset$combined_needs_index <- social_dataset$total_need_IRSAD + 
    social_dataset$total_transport_need 
  social_dataset$combined_needs_index <- rescale_max(
     social_dataset$combined_needs_index, to = c(0, 100))
  
  
  return(social_dataset %>% 
           select(sa1_code_2021, combined_needs_index, population, sa3_name_2021)) 
}

combined_needs_index_2021_sa1_greater_melbourne <- calculate_IRSAD_and_need_index(
  social_2021_sa1_greater_melbourne)

# Reuse the set thresholds function (but cheat by switching name of column two to SIs)
thresholds_holding <- combined_needs_index_2021_sa1_greater_melbourne %>%
  st_drop_geometry() %>% 
  select(sa1_code_2021, combined_needs_index) 
names(thresholds_holding) <- c("area_id", "SI")  

thresholds_holding <- set_thresholds(thresholds_holding)
names(thresholds_holding[[1]]) <- c("sa1_code_2021", "combined_needs_index", "composite_needs")
thresholds_holding[[1]]$composite_needs <- thresholds_holding[[1]]$composite_needs %>% fct_other(keep = c("Very Low", "Low", "Below average", "Above average", "High", "Very High"), other_level = "NA")

#join to sa1 geometry data
combined_needs_index_2021_sa1_greater_melbourne <- left_join(
  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Melbourne") %>% 
    select(sa1_code_2021),
  thresholds_holding[[1]] 
)


ggplot()+ 
  geom_sf(data=combined_needs_index_2021_sa1_greater_melbourne %>% na.omit(),
          aes(fill =  composite_needs), colour=NA) +
  theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank(), #remove y axis ticks
        legend.position="bottom",
        legend.text = element_text(size = 4), 
        legend.title = element_text(size = 5)) + 
  scale_fill_manual(values = c("#FFFB07", "#CEE102", "#A3CF07", "#61AE09", "#2EA105", "#0A7B01")) +
  geom_sf(data=melbourne_sd07aust_region, fill = NA, linewidth = 1) +
  geom_sf(data=middle_lga07aust_region, fill = NA, linewidth = 0.75)





```


Figure \ref{fig:Greater_Melbourne_2021_social_needs} appears to indicate that there is no clear spatial pattern to the distribution of the categories of the composite need index scores. This appears to contrast to trend, albeit with some exceptions, towards very high social needs scores in outer areas identified by @currie2010identifying (Figure \ref{fig:Currie_map_needs}). This may, however, be an artifact of either the differences in the composite needs scores used in this analysis (due to the lack of data to assess relative needs) compared to the @currie2010identifying analysis. As well, the 2021 census SA1 zones generally appear to smalller than the 2006 Census Collection Districts (CCDs) used in @currie2010identifying, especially in outer areas. This will be associated with the growth of Greater Melbourne's population and spatial dispersment, with many of the large outer 'Very High' CCDs shown in the 2006 map now split into many more SA1 zones.  

### Needs-gap analysis


```{r Greater_Melbourne_2021_needs_gap, fig.show="hold", eval = FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Distribution of categories of composite social need index scores"}

combined_needs_index_2021_sa1_greater_melbourne <- 
  left_join(combined_needs_index_2021_sa1_greater_melbourne %>% 
              st_drop_geometry() %>%
              na.omit(), 
            si_by_area_2016_2021 %>% 
              st_drop_geometry() %>% filter(Year == 2021))

combined_needs_index_2021_sa1_greater_melbourne[is.na(combined_needs_index_2021_sa1_greater_melbourne)] <- "Zero" 

combined_needs_index_2021_sa1_greater_melbourne$combined_needs_index_binned <- 
  fct_rev(combined_needs_index_2021_sa1_greater_melbourne$combined_needs_index_binned)

Greater_Melbourne_2021_needs_gap_SA1_count <- tabyl(combined_needs_index_2021_sa1_greater_melbourne, SI_binned, combined_needs_index_binned)

#Greater_Melbourne_2021_needs_gap_SA1_count %>% 
#  adorn_totals(where = c("row", "col")) %>% 
#  adorn_percentages(denominator = "all") %>% 
#  adorn_pct_formatting() %>%
#  adorn_ns() %>% 
#  kable(caption = "Number of SA1 zones by social/transport need and public transport supply category")


Greater_Melbourne_2021_needs_gap_SA1_count_longer <- Greater_Melbourne_2021_needs_gap_SA1_count %>% 
  pivot_longer( 
    cols = 2:7, 
    values_to = "Zones",
    names_to = "Social/transport needs"
  )

Greater_Melbourne_2021_needs_gap_SA1_count_longer$Year <- 2021

```



```{r Greater_Melbourne_2021_needs_gap_percentage, fig.show="hold", eval = FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Distribution of categories of composite social need index scores"}

Greater_Melbourne_2021_needs_gap_SA1_population <- tapply(combined_needs_index_2021_sa1_greater_melbourne$population,
       list(combined_needs_index_2021_sa1_greater_melbourne$SI_binned, combined_needs_index_2021_sa1_greater_melbourne$combined_needs_index_binned), 
       sum) %>% 
  as.data.frame() %>%
  rownames_to_column() 

names(Greater_Melbourne_2021_needs_gap_SA1_population) <- c("Supply Index category", "Very high", "High", "Above average", "Below average", 
                "Low", "Very low")

#Greater_Melbourne_2021_needs_gap_SA1_population %>%
#  adorn_totals(where = c("row", "col")) %>%
#  adorn_percentages(denominator = "all") %>% 
#  adorn_pct_formatting() %>%
#  adorn_ns() %>% 
#  kable(caption = "Population of SA1 zones by social/transport need and public transport supply category")


Greater_Melbourne_2021_needs_gap_SA1_population_longer <- Greater_Melbourne_2021_needs_gap_SA1_population %>% 
  pivot_longer( 
    cols = 2:7, 
    values_to = "Population",
    names_to = "Social/transport needs"
  )

Greater_Melbourne_2021_needs_gap_SA1_population_longer$Year <- 2021
          
```



```{r Greater_Melbourne_2006_2021_needs_gap_zones, fig.show="hold", eval = FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Number of areas by SI and social/transport need category, comparison between 2006 and 2021"}

Greater_Melbourne_2006_needs_gap_SA1_count <- tibble(
  "Supply Index category" = c(
    "Zero", 
    "Very low", 
    "Low", 
    "Below average", 
    "Above average",  
    "High",
    "Very high"), 
  "Very high" = c(89, 190, 209, 189, 74, 53, 53),
  "High" = c(32, 212, 214, 205, 61, 66, 39), 
  "Above average" = c(16, 230, 256, 191, 81, 62, 43), 
  "Below average" = c(18, 245, 221, 261, 121, 92, 75), 
  "Low" = c(25, 218, 217, 237, 116, 98, 146), 
  "Very low" = c(6, 164, 176, 206, 147, 161, 205)
)

#Greater_Melbourne_2006_needs_gap_SA1_count %>% 
#  adorn_totals(where = c("row", "col")) %>%
#  kable()

Greater_Melbourne_2006_needs_gap_SA1_count_longer <- Greater_Melbourne_2006_needs_gap_SA1_count %>% 
  pivot_longer( 
    cols = 2:7, 
    values_to = "Zones",
    names_to = "Social/transport needs"
  )


Greater_Melbourne_2006_needs_gap_SA1_count_longer$Year <- 2006

names(Greater_Melbourne_2021_needs_gap_SA1_count_longer) <- c(
  "Supply Index category",
  "Social/transport needs", 
  "Zones", 
  "Year")

Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer  <- 
  add_row(
    Greater_Melbourne_2006_needs_gap_SA1_count_longer,
    Greater_Melbourne_2021_needs_gap_SA1_count_longer)

Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$`Supply Index` <- Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$`Supply Index category` %>% 
  factor(levels = c(
    "Zero", 
    "Very low", 
    "Low", 
    "Below average", 
    "Above average",  
    "High",
    "Very high"
  ))


Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$`Social/transport needs` <- Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$`Social/transport needs` %>% 
  factor(levels = c(
    "Very low", 
    "Low", 
    "Below average", 
    "Above average",  
    "High",
    "Very high"
  ))

Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$`Social/transport needs`

Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$Year <- Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer$Year %>% as_factor()

grouped_ggbarstats(
  data = Greater_Melbourne_2006_2021_needs_gap_SA1_count_longer,
  x = `Social/transport needs`,
  y = Year,
  counts = Zones,
  grouping.var = `Supply Index category`
)

```



```{r Greater_Melbourne_2006_2021_needs_gap_population, fig.show="hold", eval = FALSE, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Population by SI and social/transport need category, comparison between 2006 and 2021"}


Greater_Melbourne_2006_needs_gap_SA1_population <- tibble(
  "Supply Index category" = c(
    "Zero", 
    "Very low", 
    "Low", 
    "Below average", 
    "Above average",  
    "High",
    "Very high"), 
  "Very high" = c(37699, 101305, 137735, 120934, 41702, 27149, 24691),
  "High" = c(14338, 131554, 141273, 119981, 33000, 33314, 16563), 
  "Above average" = c(7985, 140757, 169648, 113281, 43622, 30694, 20393), 
  "Below average" = c(9416, 154876, 146209, 153874, 62783, 42802, 35865), 
  "Low" = c(13263, 140874, 148078, 140390, 60952, 48912, 61719), 
  "Very low" = c(2722, 118926, 119906, 126061, 79117, 76597, 90181)
)



#Greater_Melbourne_2006_needs_gap_SA1_population %>% 
#  adorn_totals(where = c("row", "col")) %>%
#  adorn_percentages(denominator = "all") %>%
#  adorn_pct_formatting() %>% 
#  adorn_ns() %>%
#  kable()


Greater_Melbourne_2006_needs_gap_SA1_population_longer <- Greater_Melbourne_2006_needs_gap_SA1_population %>% 
  pivot_longer( 
    cols = 2:7, 
    values_to = "Population",
    names_to = "Social/transport needs"
  )

Greater_Melbourne_2006_needs_gap_SA1_population_longer$Year <- 2006

Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer  <- 
  add_row(
    Greater_Melbourne_2006_needs_gap_SA1_population_longer,
    Greater_Melbourne_2021_needs_gap_SA1_population_longer)

Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$`Supply Index category` <- Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$`Supply Index category` %>% 
  factor(levels = c(
    "Zero", 
    "Very low", 
    "Low", 
    "Below average", 
    "Above average",  
    "High",
    "Very high"
  ))


Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$`Social/transport needs` <- Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$`Social/transport needs` %>% 
  factor(levels = c(
    "Very low", 
    "Low", 
    "Below average", 
    "Above average",  
    "High",
    "Very high"
  ))


Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$Year <- Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$Year %>% as_factor()

Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$`Supply Index category` <- Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer$`Supply Index category`%>% 
  as.character()


grouped_ggbarstats(
  data = Greater_Melbourne_2006_2021_needs_gap_SA1_population_longer,
  x = `Social/transport needs`,
  y = Year,
  counts = Population,
  grouping.var = `Supply Index category`
)


```



## Variation in spatial patterns across Australian cities

```{r Australian_cities_2021, fig.show="hold", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Transit Supply by SA1, weeks starting the date of 2021 census"}

## 2021 Greater Adelaide
si_by_area <-  read.csv( "results/Greater_Adelaide/adelaide_si_SA12021_21_census_week_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]

areas_of_interest <-  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Adelaide") %>% 
    select(sa1_code_2021)

adelaide_si_SA12021_21_census_week_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

## 2021 Greater Brisbane
si_by_area <-  read.csv( "results/Greater_Brisbane/brisbane_si_SA12021_21_census_week_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]

areas_of_interest <-  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Brisbane") %>% 
    select(sa1_code_2021)

brisbane_si_SA12021_21_census_week_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

## 2021 Greater Hobart
si_by_area <-  read.csv( "results/Greater_Hobart/hobart_si_SA12021_21_census_week_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]

areas_of_interest <-  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Hobart") %>% 
    select(sa1_code_2021)

hobart_si_SA12021_21_census_week_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)

## 2021 Greater Perth
si_by_area <-  read.csv( "results/Greater_Perth/perth_si_SA12021_21_census_week_aggregated.csv") %>% 
  as_tibble()
si_by_area <- si_by_area[,2:3]

areas_of_interest <-  absmapsdata::sa12021 %>% 
    filter(gcc_name_2021 == "Greater Perth") %>% 
    select(sa1_code_2021)

perth_si_SA12021_21_census_week_aggregated <- si_thresholds_and_plot_function(si_by_area, areas_of_interest)



melbourne_si_SA12021_21_census_week_aggregated[["output_plot"]] 
adelaide_si_SA12021_21_census_week_aggregated[["output_plot"]] 
brisbane_si_SA12021_21_census_week_aggregated[["output_plot"]] 
hobart_si_SA12021_21_census_week_aggregated[["output_plot"]] 
perth_si_SA12021_21_census_week_aggregated[["output_plot"]] 

```



Figure \ref{fig:Australian_cities_2021} shows SI values for the week starting on the day of the 2021 census for all Australian Capital Cities except Greater Sydney, for which the SI values are calculated for the week starting <INSERT WEEK HERE>. 




# Discussion

## Limitations 

## Directions for furture research

# Conclusions

# References {-}



```{r, include=FALSE}
knitr::write_bib(file = 'packages.bib')
```

# Appendix A - GCCSA maps by SA1

```{r Greater_Melbourne_SA1_2021_plot, fig.show="hold", echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE, fig.fullwidth = TRUE, fig.cap="Greater Melbourne, Transit Supply by SA1, week starting the date of 2021 census, with 2006 Melbourne boundary shown in black"}

melbourne_si_SA12021_21_census_week_aggregated$output_plot + 
  geom_sf(data=melbourne_sd07aust_region, fill = NA, linewidth = 1) +
  geom_sf(data=middle_lga07aust_region, fill = NA, linewidth = 0.75) +
  geom_sf(data=melbourne_sd07aust_region, 
          colour="black", 
          fill=NA)

```

